var defaults = {
    cache: false,
    beautify: true,
    debug: true
};

function extend(dest) {
    Array.prototype.slice.call(arguments, 1).forEach(function (src) {
        for (var i in src) {
            dest[i] = src[i];
        }
    });
    return dest;
}

/**
 * Returns a render function.
 *
 * Render function takes the template's `path`, actual `data` and invokes the callback `fn(err, str)`.
 *
 * Options:
 *
 *   - `cache`    cache compiled functions
 *   - `beautify` beautify compiled functions
 *   - `debug`    include debugging information
 *   - `errorFn`  a function to log runtime errors
 *
 * @param {Options} options
 * @return {Function}
 */
exports.render = function (options) {

    var fs = require('fs'),
        fest = require('fest'),
        cache = {};

    options = extend({}, defaults, options);

    return function (path, data, fn) {
        if (options.cache && path in cache) {
            try {
                fn(null, cache[path](data));
            } catch (err) {
                fn(err);
            }
        } else {
            fs.stat(path, function (err, stats) {
                if (err) {
                    fn(err);
                } else try {
                    if (!stats.isFile()) {
                        fn(new Error('File "' + path + '" is not a regular file.'));
                    }
                    var code = fest.compile(path, extend({}, options)),
                        tmpl = (new Function('__fest_error', 'return ' + code))(options.errorFn);
                    if (options.cache) {
                        cache[path] = tmpl;
                    }
                    fn(null, tmpl(data));
                } catch (err) {
                    fn(err);
                }
            });
        }
    };

}

/**
 * Returns a synchronous version of render function.
 *
 * Synchronous render function takes the template's `path`, actual `data` and returns `str`.
 *
 * Options:
 *
 *   - `cache`    cache compiled functions
 *   - `beautify` beautify compiled functions
 *   - `debug`    include debugging information
 *   - `errorFn`  a function to log runtime errors
 *
 * @param {Options} options
 * @return {Function}
 */
exports.renderSync = function (options) {

    var fs = require('fs'),
        fest = require('fest'),
        cache = {};

    options = extend({}, defaults, options);

    return function (path, data) {
        if (options.cache && path in cache) {
            return cache[path](data);
        } else {
            var stats = fs.statSync(path);
            if (!stats.isFile()) {
                throw new Error('File "' + path + '" is not a regular file.');
            }
            var code = fest.compile(path, extend({}, options)),
                tmpl = (new Function('__fest_error', 'return ' + code))(options.errorFn);
            if (options.cache) {
                cache[path] = tmpl;
            }
            return tmpl(data);
        }
    };

}

var formats = {
    'amd': 'define(function(){return #FN#});'
};

/**
 * Returns a Connect's middleware.
 *
 * Allows to compile the templates into JavaScript files on the fly.
 * Supports JSONP, AMD or custom output formatting.
 *
 * Options:
 *
 *   - `route`     mounting point for the middleware
 *   - `templates` path to the templates directory
 *   - `format`    output formating string or 'amd' (default) or 'jsonp'
 *   - `maxAge`    http cache max-age in milliseconds (defaults to 0)
 *   - `cache`     cache compiled functions
 *   - `beautify`  beautify compiled functions
 *   - `debug`     include debugging information
 *
 * @param {Options} options
 * @return {Function}
 */
exports.proxy = function (options) {

    var fs = require('fs'),
        url = require('url'),
        fest = require('fest'),
        cache = {};

    options = extend({
        maxAge: 0,
        format: 'amd'
    }, defaults, options);

    if (!options.route) throw new Error('route is required');
    if (!options.templates) throw new Error('tempates is required');

    if (options.route[0] !== '/') options.route = '/' + options.route;
    if (options.route.slice(-1) !== '/') options.route += '/';

    if (options.format in formats) {
        options.format = formats[options.format];
    }

    return function (req, res, next) {

        if (req.method !== 'HEAD' && req.method !== 'GET') return next();

        try {
            var uo = url.parse(req.url, true),
                path = decodeURIComponent(uo.pathname),
                jsonp = decodeURIComponent(uo.query.jsonp);
        } catch (e) {
            return next(e);
        }

        if (0 !== path.indexOf(options.route) || path.slice(-3) !== '.js') {
            return next();
        }

        var id = path.slice(options.route.length).slice(0, -3);

        path = options.templates + '/' + id + '.xml';

        function send(file) {

            if (options.format === 'jsonp' && jsonp) {
                file.content = jsonp + '(' + file.content + ');';
                file.ts = new Date;
            }

            res.setHeader('Date', (new Date).toUTCString());
            res.setHeader('Cache-Control', 'public, max-age=' + options.maxAge);
            res.setHeader('Last-Modified', file.ts.toUTCString());

            var ms = req.headers['if-modified-since'];
            if (ms) {
                ms = new Date(ms);
                if (!isNaN(ms.valueOf()) && ms >= file.ts) {
                    res.statusCode = 304;
                    return res.end();
                }
            }

            res.setHeader('Content-Type', 'application/javascript');
            res.setHeader('Content-Length', Buffer.byteLength(file.content, 'utf8'));

            if (req.method == 'HEAD') {
                res.end();
            } else {
                res.end(file.content);
            }
        }

        if (options.cache && path in cache) {
            send(cache[path]);
        } else {
            fs.stat(path, function (err, stats) {
                if (err) {
                    return next();
                } else try {
                    if (!stats.isFile()) {
                        return next();
                    }
                    var content = fest.compile(path, extend({}, options));
                    if (options.format !== 'jsonp') {
                        content = options.format
                                    .replace(/#ID#/g, id.replace(/\'/g, "\\'").replace(/\"/g, '\\"').replace(/\\/g, '\\'))
                                    .replace(/#FN#/g, content);
                    }
                    var file = {
                            content: content,
                            ts: new Date
                        };
                    if (options.cache) {
                        cache[path] = file;
                    }
                    send(file);
                } catch (err) {
                    next(err);
                }
            });
        }
    };

}
