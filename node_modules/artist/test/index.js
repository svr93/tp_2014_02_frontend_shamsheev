var assert = require('assert'),
    artist = require('..'),
    http = require('./http');

describe("api", function() {
    describe(".render(opts)", function () {

        it("should invoke the function with null and a string", function () {
            var errors = [],
                render = artist.render({
                    cache: true,
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            // compile
            render(__dirname + '/test.xml', {foo: 'bar'}, function (err, str) {
                assert.equal(err, null);
                assert.equal(str, 'bar');
                // no runtime errors
                assert.deepEqual(errors, []);
            });
            // from cache
            render(__dirname + '/test.xml', {foo: 'bar'}, function (err, str) {
                assert.equal(err, null);
                assert.equal(str, 'bar');
                // no runtime errors
                assert.deepEqual(errors, []);
            });
        });

        it("should invoke the function with an error when the file doesn't exist", function () {
            var errors = [],
                render = artist.render({
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            render(__dirname + '/nonexistent.xml', {}, function (err, str) {
                assert.notEqual(err, null);
                assert.equal(err.code, 'ENOENT');
                assert.equal(str, undefined);
                // no runtime errors
                assert.deepEqual(errors, []);
            });
        });

        it("should invoke the function with an error when the file contains syntax errors", function () {
            var errors = [],
                render = artist.render({
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            render(__dirname + '/error-syntax.xml', {}, function (err, str) {
                assert.notEqual(err, null);
                assert(err.message.match(/Unexpected close tag/));
                assert.equal(str, undefined);
                // no runtime errors
                assert.deepEqual(errors, []);
            });
        });

        it("should log an message when the file contains runtime error", function () {
            var errors = [],
                render = artist.render({
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            render(__dirname + '/error-runtime.xml', {}, function (err, str) {
                assert.equal(err, null);
                assert.equal(str, '');
                // runtime errors
                assert.equal(errors.length, 1);
                assert(errors[0].match(/Cannot read property 'bar' of undefined/));
            });
        });
    });

    describe(".renderSync(opts)", function () {

        it("should return a string", function () {
            var errors = [],
                render = artist.renderSync({
                    cache: true,
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            // compile
            assert.equal(render(__dirname + '/test.xml', {foo: 'bar'}), 'bar');
            // from cache
            assert.equal(render(__dirname + '/test.xml', {foo: 'bar'}), 'bar');
            // no runtime errors
            assert.deepEqual(errors, []);
        });

        it("should throw an error when the file doesn't exist", function () {
            var errors = [],
                render = artist.renderSync({
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            assert.throws(function () {
                render(__dirname + '/nonexistent.xml', {});
            }, function (err) {
                return err.code === 'ENOENT';
            })
            // no runtime errors
            assert.deepEqual(errors, []);
        });

        it("should throw an error when the file contains syntax errors", function () {
            var errors = [],
                render = artist.renderSync({
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            assert.throws(function () {
                render(__dirname + '/error-syntax.xml', {});
            }, /Unexpected close tag/);
            // no runtime errors
            assert.deepEqual(errors, []);
        });

        it("should log an message when the file contains runtime error", function () {
            var errors = [],
                render = artist.renderSync({
                    errorFn: function (err) {
                        errors.push(err)
                    }
                });
            render(__dirname + '/error-runtime.xml', {});
            // runtime errors
            assert.equal(errors.length, 1);
            assert(errors[0].match(/Cannot read property 'bar' of undefined/));
        });
    });

    describe(".proxy(opts)", function () {

        function performRequest(proxy, request, callback) {
            var req = new http.Request(request),
                res = new http.Response();
            res.on('finish', function () {
                callback(null, res);
            });
            proxy(req, res, function (err) {
                callback(err, res);
            });
        }

        var defaultProxy = artist.proxy({
            // format: 'amd',
            route: '/scripts',
            templates: __dirname
        });

        var cacheProxy = artist.proxy({
            cache: true,
            route: '/scripts',
            templates: __dirname
        });

        var jsonpProxy = artist.proxy({
            format: 'jsonp',
            route: '/scripts',
            templates: __dirname,
            maxAge: 86400000
        });

        var festProxy = artist.proxy({
            format: ';(function(x){if(!x.fest)x.fest={};x.fest["#ID#"]=#FN#})(this);',
            route: '/scripts',
            templates: __dirname
        });

        it("should throw an exception if required parameters are missing", function () {
            assert.throws(function () {
                artist.proxy()
            }, /route is required/);
            assert.throws(function () {
                artist.proxy({route: '/'})
            }, /tempates is required/);
        });

        it("should format the function into AMD module by default and prevent browser cache", function (done) {
            performRequest(defaultProxy, {
                method: 'GET',
                url: '/scripts/test.js'
            }, function (err, res) {
                assert(res.finished);
                assert.equal(res.statusCode, 200);
                assert.equal(res._headers['cache-control'], 'public, max-age=0');
                assert(res.match(/^define\(function\(\)\{return [\s\S]*\}\);$/));
                done(err);
            });
        });

        it("should format the function into JSONP reponse and send custom Cache-Control header", function (done) {
            performRequest(jsonpProxy, {
                method: 'GET',
                url: '/scripts/test.js?jsonp=cb1'
            }, function (err, res) {
                assert(res.finished);
                assert.equal(res.statusCode, 200);
                assert(res.match(/^cb1\([\s\S]*\);$/));
                assert.equal(res._headers['cache-control'], 'public, max-age=86400000');
                done(err);
            });
        });

        it("should format the function into JSONP response with different jsonp values", function (done) {
            performRequest(jsonpProxy, {
                method: 'GET',
                url: '/scripts/test.js?jsonp=cb2'
            }, function (err, res) {
                assert(res.finished);
                assert.equal(res.statusCode, 200);
                assert(res.match(/^cb2\([\s\S]*\);$/));
                done(err);
            });
        });


        it("should format the function into custom layout", function (done) {
            performRequest(festProxy, {
                method: 'GET',
                url: '/scripts/test.js'
            }, function (err, res) {
                assert(res.finished);
                assert.equal(res.statusCode, 200);
                assert(res.match(/^;\(function\(x\)\{if\(!x\.fest\)x\.fest=\{\};x\.fest\["test"\]=[\s\S]*\}\)\(this\);$/));
                done(err);
            });
        });

        it("should just call next() when the route mismatch", function (done) {
            performRequest(defaultProxy, {
                method: 'GET',
                url: '/templates/test.js'
            }, function (err, res) {
                assert(!res.finished);
                done(err);
            });
        });

        it("should deal with HEAD requests", function (done) {
            performRequest(defaultProxy, {
                method: 'HEAD',
                url: '/scripts/test.js'
            }, function (err, res) {
                assert(res.finished);
                assert.equal(res.statusCode, 200);
                assert(res.match(''));
                done(err);
            });
        });

        it("should deal with HEAD and GET requests only", function (done) {
            performRequest(defaultProxy, {
                method: 'POST',
                url: '/scripts/test.js'
            }, function (err, res) {
                assert(!res.finished);
                done(err);
            });
        });

        it("should deal with If-Modified-Since header", function (done) {
            performRequest(cacheProxy, {
                headers: {'if-modified-since': (new Date).toUTCString()},
                method: 'GET',
                url: '/scripts/test.js'
            }, function (err, res) {
                assert(res.finished);
                assert.equal(res.statusCode, 200);
                assert(!res.match(''));
                if (err) {
                    done(err);
                } else {
                    performRequest(cacheProxy, {
                        headers: {'if-modified-since': (new Date(Date.now() + 60 * 1000)).toUTCString()},
                        method: 'GET',
                        url: '/scripts/test.js'
                    }, function (err, res) {
                        assert(res.finished);
                        assert.equal(res.statusCode, 304);
                        assert(res.match(''));
                        done(err);
                    });
                }
            });
        });
    });
});
